<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>ãƒ•ã‚©ãƒ«ãƒ€å†…ã®æ–‡å­—åˆ—ä¸€æ‹¬ç½®æ›</title>
  <style>
    body { font-family: sans-serif; padding: 1em; }
    label { display: block; margin-top: 1em; }
    #output {
      white-space: pre-wrap;
      background: #f9f9f9;
      border: 1px solid #ccc;
      padding: 1em;
      margin-top: 1em;
      max-height: 400px;
      overflow-y: auto;
    }
    button { margin-top: 1em; }
  </style>
</head>
<body>
  <h2>ãƒ•ã‚©ãƒ«ãƒ€å†…ã®å…¨ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä¸€æ‹¬ç½®æ›ï¼ˆæŒ‡å®šã—ãŸãƒ•ã‚©ãƒ«ãƒ€ã®ä¸­ã« ã€Œãƒ•ã‚©ãƒ«ãƒ€å_replacedã€ ãƒ•ã‚©ãƒ«ãƒ€ãŒç”Ÿæˆã•ã‚Œã¾ã™ï¼‰</h2>
  
  <label>
    æ¤œç´¢æ–‡å­—åˆ—:
    <input type="text" id="searchText" placeholder="ç½®æ›ã—ãŸã„æ–‡å­—åˆ—">
  </label>
  <label>
    ç½®æ›å¾Œã®æ–‡å­—åˆ—:
    <input type="text" id="replaceText" placeholder="ç½®æ›å¾Œã®æ–‡å­—åˆ—">
  </label>
  <label>
    <input type="checkbox" id="backupZip" checked="checked"> å‡¦ç†å‰ã«ZIPãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—
  </label>
  
  <button id="selectFolderBtn">ãƒ•ã‚©ãƒ«ãƒ€ã‚’é¸æŠã—ã¦ç½®æ›å®Ÿè¡Œ</button>
  <div id="output"></div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <script>
    const excludedExtensions = [
      '.meta', '.png', '.jpg', '.jpeg', '.gif', '.webp', '.svg', '.ico',
      '.mp4', '.webm', '.mp3', '.wav', '.zip', '.tar', '.gz', '.exe',
      '.dll', '.class', '.jar', '.so', '.bin', '.dat', '.ttf', '.woff', '.woff2'
    ];

    const forbiddenKeywords = [
      '/', '\\', 'windows', 'system32', 'program files', 'programdata',
      'users', 'appdata', 'system', 'library', 'applications',
      'bin', 'etc', 'usr', 'var', 'root', 'dev'
    ];

    function isProbablyGarbled(text) {
      const totalLength = text.length;
      if (totalLength === 0) return false;

      const nonPrintable = (text.match(/[\x00-\x08\x0E-\x1F\x7F]/g) || []).length;
      const replacementChars = (text.match(/\uFFFD/g) || []).length;
      const nullChars = (text.match(/\x00/g) || []).length;

      return (
        nonPrintable / totalLength > 0.1 ||
        replacementChars / totalLength > 0.05 ||
        nullChars > 0
      );
    }

    function isForbiddenFolderPath(folderName) {
      const lowerPath = folderName.toLowerCase();
      return forbiddenKeywords.some(keyword => lowerPath.includes(keyword));
    }

    async function copyDirectory(srcHandle, destHandle) {
      for await (const entry of srcHandle.values()) {
        if (entry.kind === 'file') {
          const file = await entry.getFile();
          const destFileHandle = await destHandle.getFileHandle(entry.name, { create: true });
          const writable = await destFileHandle.createWritable();
          await writable.write(await file.arrayBuffer());
          await writable.close();
        } else if (entry.kind === 'directory') {
          const newDestDir = await destHandle.getDirectoryHandle(entry.name, { create: true });
          if(!newDestDir.name.endsWith("_replaced")) {
            await copyDirectory(entry, newDestDir);
          }
          else
          {
            try {
              await destHandle.removeEntry(entry.name, { recursive: true });
            } catch (err) {
            }
          }
        }
      }
    }

    async function replaceInFiles(handle, searchText, replaceText, output) {
      let modifiedFiles = 0;
      for await (const entry of handle.values()) {
        if (entry.kind === 'file') {
          const lowerName = entry.name.toLowerCase();
          if (excludedExtensions.some(ext => lowerName.endsWith(ext))) {
            output.textContent += `âš  ã‚¹ã‚­ãƒƒãƒ—: ${entry.name}ï¼ˆé™¤å¤–æ‹¡å¼µå­ï¼‰\n`;
            continue;
          }

          const fileHandle = entry;
          const file = await fileHandle.getFile();
          const text = await file.text();

          if (isProbablyGarbled(text)) {
            output.textContent += `âš  ã‚¹ã‚­ãƒƒãƒ—: ${entry.name}ï¼ˆæ–‡å­—åŒ–ã‘æ¤œå‡ºï¼‰\n`;
            continue;
          }

          if (text.includes(searchText)) {
            const updatedText = text.split(searchText).join(replaceText);
            const writable = await fileHandle.createWritable();
            await writable.write(updatedText);
            await writable.close();
            modifiedFiles++;
            output.textContent += `âœ” ç½®æ›: ${entry.name}\n`;
          }
        } else if (entry.kind === 'directory') {
          modifiedFiles += await replaceInFiles(entry, searchText, replaceText, output);
        }
      }
      return modifiedFiles;
    }

    document.getElementById('selectFolderBtn').addEventListener('click', async () => {
      const searchText = document.getElementById('searchText').value;
      const replaceText = document.getElementById('replaceText').value;
      const backupZip = document.getElementById('backupZip').checked;
      const output = document.getElementById('output');
      output.textContent = '';

      if (!searchText) {
        alert("æ¤œç´¢æ–‡å­—åˆ—ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚");
        return;
      }

      try {
        const dirHandle = await window.showDirectoryPicker();
        const folderName = dirHandle.name;
        const replacedName = folderName.endsWith('_replaced') ? folderName : `${folderName}_replaced`;

        if (isForbiddenFolderPath(folderName)) {
          alert(`ğŸš« ã“ã®ãƒ•ã‚©ãƒ«ãƒ€ã¯å±é™ºãªãŸã‚æ“ä½œã§ãã¾ã›ã‚“: ${folderName}`);
          output.textContent = `âŒ ç¦æ­¢ãƒ•ã‚©ãƒ«ãƒ€: ${folderName}`;
          return;
        }

        const parentHandle = dirHandle;
        let targetHandle;

        try {
          targetHandle = await parentHandle.getDirectoryHandle(replacedName);
          output.textContent += `âš  æ—¢ã«ã‚³ãƒ”ãƒ¼å…ˆãƒ•ã‚©ãƒ«ãƒ€ ${replacedName} ãŒå­˜åœ¨ã—ã¾ã™ã€‚ã‚³ãƒ”ãƒ¼ã›ãšãã®ã¾ã¾ç½®æ›ã—ã¾ã™ã€‚\n`;
        } catch {
          output.textContent += `ğŸ“ ã‚³ãƒ”ãƒ¼å…ˆãƒ•ã‚©ãƒ«ãƒ€ã‚’ä½œæˆ: ${replacedName}\n`;
          targetHandle = await parentHandle.getDirectoryHandle(replacedName, { create: true });
          await copyDirectory(dirHandle, targetHandle);
          output.textContent += "âœ” ãƒ•ã‚©ãƒ«ãƒ€ã‚³ãƒ”ãƒ¼å®Œäº†\n";
        }

        // ZIPãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰
        if (backupZip) {
          output.textContent += "ğŸ”„ ZIPãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ä½œæˆä¸­...\n";
          const zip = new JSZip();
          await addToZip(targetHandle, zip);
          const blob = await zip.generateAsync({ type: "blob" });
          const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
          const backupFileName = `backup-${replacedName}-${timestamp}.zip`;
          const backupHandle = await parentHandle.getFileHandle(backupFileName, { create: true });
          const writable = await backupHandle.createWritable();
          await writable.write(blob);
          await writable.close();
          output.textContent += `âœ” ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã‚’ ${backupFileName} ã¨ã—ã¦ä¿å­˜ã—ã¾ã—ãŸã€‚\n`;
        }

        output.textContent += "ğŸ” ã‚³ãƒ”ãƒ¼å…ˆã§ç½®æ›å‡¦ç†ã‚’é–‹å§‹...\n";
        const modifiedFiles = await replaceInFiles(targetHandle, searchText, replaceText, output);

        if (modifiedFiles > 0) {
          output.textContent += `\nâœ… ${modifiedFiles} ä»¶ã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ç½®æ›ã—ã¾ã—ãŸã€‚`;
        } else {
          output.textContent += `\nâš  ç½®æ›å¯¾è±¡ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚`;
        }

      } catch (err) {
        console.error(err);
        output.textContent = `âŒ ã‚¨ãƒ©ãƒ¼: ${err.message}`;
      }
    });

    async function addToZip(handle, zip, path = "") {
      for await (const entry of handle.values()) {
        const entryPath = path + entry.name;
        if (entry.kind === 'file') {
          const file = await entry.getFile();
          const content = await file.arrayBuffer();
          zip.file(entryPath, content);
        } else if (entry.kind === 'directory') {
          await addToZip(entry, zip, entryPath + "/");
        }
      }
    }
  </script>
</body>
</html>
